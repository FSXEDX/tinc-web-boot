package main

import (
	"context"
	"fmt"
	"github.com/alecthomas/kong"
	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
	"io/ioutil"
	"log"
	"net"
	"net/http"
	"os"
	"os/signal"
	"strconv"
	"time"
	"tinc-web-boot/cmd/tinc-web-boot/internal"
	"tinc-web-boot/network"
	"tinc-web-boot/tincd"
	"tinc-web-boot/utils"
	"tinc-web-boot/web"
)

var version = "dev"

type globalContext struct {
	ctx context.Context
}

type Main struct {
	Run     Root             `cmd:"run" default:"1"`
	Join    join             `cmd:"join" help:"Join by majordomo"`
	List    listNetworks     `cmd:"list" help:"List networks"`
	Info    getNetwork       `cmd:"info" help:"Get network info"`
	Share   shareNetwork     `cmd:"share" help:"Share network"`
	Import  importNetwork    `cmd:"import" help:"Import network"`
	Start   start            `cmd:"start" help:"Start network"`
	Stop    stop             `cmd:"stop" help:"Stop network"`
	Peers   peers            `cmd:"peers" help:"List connected peers"`
	Version kong.VersionFlag `name:"version" help:"print version and exit"`
}

type Root struct {
	TincBin            string   `name:"tinc-bin" env:"TINC_BIN" help:"Custom tinc binary location" default:"tincd"`
	Host               string   `name:"host" env:"HOST" help:"Binding host" default:"127.0.0.1"`
	Dir                string   `name:"dir" env:"DIR" help:"Directory for config" default:"networks"`
	Dev                bool     `name:"dev" env:"DEV" help:"Enable DEV mode (CORS + logging)"`
	Headless           bool     `long:"headless" env:"HEADLESS" description:"Disable launch browser"`
	DevGenOnly         bool     `name:"dev-gen-only" env:"DEV_GEN_ONLY" help:"(dev only) generate sample config but don't run"`
	DevNet             string   `name:"dev-net" env:"DEV_NET" help:"(dev only) Name of development network" default:"example-network"`
	DevAddress         []string `name:"dev-address" env:"DEV_ADDRESS" help:"(dev only) Public addresses" default:"127.0.0.1"`
	DevPort            uint16   `name:"dev-port" env:"DEV_PORT" help:"(dev only) Development port" default:"10655"`
	DevSubnet          string   `name:"dev-subnet" env:"DEV_SUBNET" help:"(dev only) Custom subnet for sample network" default:"10.155.0.0/16"`
	NoApp              bool     `name:"no-app" env:"NO_APP" help:"Don't try to open UI in application mode (if possible)"`
	UIPublicAddress    []string `name:"ui-public-address" env:"UI_PUBLIC_ADDRESS" help:"Custom UI public addresses (host:port) for links"`
	AuthKey            string   `name:"auth-key" env:"AUTH_KEY" help:"JWT signing key (empty - autogenerated)"`
	DumpKey            string   `short:"f" name:"dump-key" env:"DUMP_KEY" help:"Dump API token" default:".tinc-web-boot"`
	Majordomo          bool     `short:"M" name:"majordomo" env:"MAJORDOMO" help:"Enable Majordomo for easy-share"`
	MajordomoNet       string   `short:"N" name:"majordomo-net" env:"MAJORDOMO_NET" help:"Allowed networks for easy-share"`
	MajordomoInterface string   `short:"I" name:"majordomo-interface" env:"MAJORDOMO_INTERFACE" help:"Use addresses from the interface"`
	internal.HttpServer
}

func main() {
	var cli Main
	ctx := kong.Parse(&cli, kong.Vars{"version": version})

	gctx, closer := context.WithCancel(context.Background())
	go func() {
		c := make(chan os.Signal, 2)
		signal.Notify(c, os.Kill, os.Interrupt)
		for range c {
			closer()
			break
		}
	}()
	defer closer()
	err := ctx.Run(&globalContext{ctx: gctx})
	ctx.FatalIfErrorf(err)
}

func (m *Root) Run(global *globalContext) error {
	if !m.Dev {
		gin.SetMode(gin.ReleaseMode)
	}

	binary, err := internal.DetectTincBinary(m.TincBin)
	if err != nil {
		return err
	}
	log.Println("detected Tinc binary:", binary)

	err = internal.Preload(global.ctx)
	if err != nil {
		return err
	}
	log.Println("preload complete")

	stor := &network.Storage{Root: m.Dir}
	err = stor.Init()
	if err != nil {
		return err
	}

	pool, err := tincd.New(global.ctx, stor, binary)
	if err != nil {
		return err
	}
	defer pool.Stop()

	if m.Dev {
		_, subnet, err := net.ParseCIDR(m.DevSubnet)
		if err != nil {
			return err
		}
		ntw, err := pool.Create(m.DevNet, subnet)
		if err != nil {
			return err
		}
		var addrs []network.Address
		for _, addr := range m.DevAddress {
			addrs = append(addrs, network.Address{
				Host: addr,
				Port: m.DevPort,
			})
		}
		err = ntw.Definition().Upgrade(network.Upgrade{
			Address: addrs,
			Port:    m.DevPort,
		})
		if err != nil {
			return err
		}
		if m.DevGenOnly {
			return nil
		}
		if !ntw.IsRunning() {
			ntw.Start()
		}
	}
	if m.AuthKey == "" {
		m.AuthKey = uuid.New().String()
	}
	_, portStr, _ := net.SplitHostPort(m.Bind)
	port, _ := strconv.Atoi(portStr)
	apiCfg := web.Config{
		Dev:             m.Dev,
		AuthorizedOnly:  m.Headless,
		AuthKey:         m.AuthKey,
		LocalUIPort:     uint16(port),
		PublicAddresses: m.UIPublicAddress,
	}
	webApi, uiApp := apiCfg.New(pool)
	if !m.Headless {
		go func() {

			for i := 0; i < 50; i++ {
				if isGuiAvailable(global.ctx, m.Bind, time.Second) {
					break
				}
				select {
				case <-time.After(100 * time.Millisecond):
				case <-global.ctx.Done():
					return
				}
			}

			err := internal.OpenInBrowser(global.ctx, "http://"+m.Bind, !m.NoApp)
			if err != nil {
				log.Println("failed to open UI:", err)
			} else {
				log.Println("UI opened")
			}
		}()
	} else {
		token, err := uiApp.IssueAccessToken(3650)
		if err != nil {
			return fmt.Errorf("issue token: %w", err)
		}
		fmt.Println("\n-------------\n\n", "TOKEN:", token, "\n\n-------------")
		if m.DumpKey != "" {
			err = ioutil.WriteFile(m.DumpKey, []byte(token), 0755)
			if err != nil {
				log.Println("[WARN]", "failed to dump key:", err)
			}
		}
	}
	if err := m.enableMajordomoIfNeeded(webApi, pool); err != nil {
		return err
	}
	return m.Serve(global.ctx, webApi)
}

func isGuiAvailable(global context.Context, url string, timeout time.Duration) bool {
	ctx, cancel := context.WithTimeout(global, timeout)
	defer cancel()
	req, err := http.NewRequestWithContext(ctx, http.MethodGet, url, nil)
	if err != nil {
		return false
	}
	res, err := http.DefaultClient.Do(req)
	if err != nil {
		return false
	}
	res.Body.Close()
	return true
}

func (m *Root) enableMajordomoIfNeeded(router gin.IRouter, pool *tincd.Tincd) error {
	if !m.Majordomo {
		return nil
	}
	ntw, err := pool.Get(m.MajordomoNet)
	if err != nil {
		return err
	}
	cfg, err := ntw.Definition().Self()
	if err != nil {
		return err
	}
	code := utils.RandStringRunes(18)
	web.ExportMajordomo(router, pool, code, m.MajordomoNet)

	_, portStr, err := net.SplitHostPort(m.Bind)

	if err != nil {
		return err
	}

	port, err := strconv.ParseUint(portStr, 10, 16)
	if err != nil {
		return err
	}

	interfaces, err := net.Interfaces()
	if err != nil {
		return err
	}

	var share internal.Share
	share.Port = uint16(port)
	share.Code = code
	share.Network = m.MajordomoNet
	share.Subnet = cfg.Subnet

	for _, iface := range interfaces {
		if m.MajordomoInterface != "" && iface.Name != m.MajordomoInterface {
			continue
		}
		list, err := iface.Addrs()
		if err != nil {
			return err
		}
		for _, addr := range list {
			if v, ok := addr.(*net.IPNet); ok && v.IP.To4() != nil {
				var bts [4]byte
				copy(bts[:], v.IP.To4())
				share.Addresses = append(share.Addresses, bts)
			}
		}
	}

	if len(share.Addresses) == 0 {
		return fmt.Errorf("no public addresses")
	}

	fmt.Println("-----------------------")
	fmt.Println("     MAJORDOMO         ")
	fmt.Println("")
	fmt.Println(share.ToHex())
	fmt.Println("")
	fmt.Println("-----------------------")

	return nil
}
